[
    {
        "id": "1",
        "type": "discordMessage",
        "z": "f6f2187d.f17ca8",
        "name": "Message Listener",
        "channelIdFilter": "",
        "token": "",
        "x": 200,
        "y": 240,
        "wires": [
            [
                "e3e7a455520dc87e"
            ]
        ]
    },
    {
        "id": "44c7802ae822270d",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Command Handler",
        "func": "let message = null;\nlet channelId = null;\n\n// Check different possible locations for message content\nif (msg.payload) {\n    message = msg.payload.content ||\n        msg.payload.text ||\n        msg.payload.message ||\n        (typeof msg.payload === 'string' ? msg.payload : null);\n}\n\n// Check different possible locations for channel ID\nif (msg.payload) {\n    channelId = msg.payload.channel?.id ||\n        msg.payload.channelId ||\n        msg.payload.channel_id;\n}\n\n// If still no message, try stringifying the entire payload\nif (!message) {\n    message = JSON.stringify(msg.payload);\n}\n\n// Fallback channelId if not found\nif (!channelId) {\n    channelId = 'unknown_channel';\n}\n\n// Minimal processing to ensure something happens\nif (message) {\n    // Basic command processing\n    const command = (typeof message === 'string' ? message : '').trim().toLowerCase();\n    \n    if (command === '!coin') {\n        msg.payload = {\n            channelId: channelId,\n            content: `ðŸª™ The coin landed on ${Math.random() > 0.5 ? \"Heads\" : \"Tails\"}!`\n        };\n        return [msg];\n    } \n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 140,
        "wires": [
            [
                "149d0ecd396c236a"
            ]
        ]
    },
    {
        "id": "149d0ecd396c236a",
        "type": "discordMessageManager",
        "z": "f6f2187d.f17ca8",
        "name": "Send Response",
        "channel": "",
        "token": "",
        "x": 1790,
        "y": 180,
        "wires": [
            []
        ]
    },
    {
        "id": "e3e7a455520dc87e",
        "type": "switch",
        "z": "f6f2187d.f17ca8",
        "name": "Command Switch",
        "property": "payload",
        "propertyType": "msg",
        "rules": [
            {
                "t": "regex",
                "v": "!dice",
                "vt": "str",
                "case": true
            },
            {
                "t": "regex",
                "v": "!coin",
                "vt": "str",
                "case": true
            },
            {
                "t": "regex",
                "v": "!trivia",
                "vt": "str",
                "case": true
            },
            {
                "t": "regex",
                "v": "!help",
                "vt": "str",
                "case": true
            },
            {
                "t": "regex",
                "v": "!mtrivia",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "!daily",
                "vt": "str",
                "case": true
            },
            {
                "t": "regex",
                "v": "!joke",
                "vt": "str",
                "case": true
            },
            {
                "t": "regex",
                "v": "!anime",
                "vt": "str",
                "case": true
            },
            {
                "t": "regex",
                "v": "!manga",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "!movie",
                "vt": "str",
                "case": false
            },
            {
                "t": "regex",
                "v": "!quote",
                "vt": "str",
                "case": true
            },
            {
                "t": "regex",
                "v": "!aquote",
                "vt": "str",
                "case": true
            },
            {
                "t": "regex",
                "v": "!game",
                "vt": "str",
                "case": true
            },
            {
                "t": "regex",
                "v": "!music",
                "vt": "str",
                "case": true
            },
            {
                "t": "regex",
                "v": "!truth",
                "vt": "str",
                "case": true
            },
            {
                "t": "regex",
                "v": "!dare",
                "vt": "str",
                "case": true
            },
            {
                "t": "regex",
                "v": "!mini",
                "vt": "str",
                "case": true
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 17,
        "x": 420,
        "y": 240,
        "wires": [
            [
                "596134bce5348145"
            ],
            [
                "44c7802ae822270d"
            ],
            [
                "81b4cedba31ab56f"
            ],
            [
                "88745405d2b1f870"
            ],
            [
                "b84a5dc887db4132"
            ],
            [
                "472446546a35cc39"
            ],
            [
                "bf5da9aa1cd098aa"
            ],
            [
                "96a7b8458dd6e819"
            ],
            [
                "cdd61a0d624b0e82"
            ],
            [
                "5a699ee4a565d261"
            ],
            [
                "2b8eaaee04854c80"
            ],
            [
                "a759f82b5f7d4f6a"
            ],
            [
                "fd30d90a3cd02d06"
            ],
            [
                "dfe8f8dedae216eb"
            ],
            [
                "7dc0d7b7b48fe645"
            ],
            [
                "4dfc77995df55bd6"
            ],
            [
                "86e101d5a252f9d3"
            ]
        ]
    },
    {
        "id": "81b4cedba31ab56f",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Prepare Trivia Request",
        "func": "const count = parseInt(msg.payload.count, 10) || 1; // Default to 1 trivia fact if not provided\nmsg.url = `https://opentdb.com/api.php?amount=${count}`;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 180,
        "wires": [
            [
                "ec153857eec39f54"
            ]
        ]
    },
    {
        "id": "ec153857eec39f54",
        "type": "http request",
        "z": "f6f2187d.f17ca8",
        "name": "Fetch Trivia from API",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "{{{url}}}",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1050,
        "y": 180,
        "wires": [
            [
                "88490cb7d5525c52"
            ]
        ]
    },
    {
        "id": "88490cb7d5525c52",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Process API Response",
        "func": "const apiResponse = msg.payload;\n\n// Function to decode HTML entities using regex\nfunction decodeHTML(html) {\n    const element = html.replace(/&#(\\d+);/g, function (match, num) {\n        return String.fromCharCode(parseInt(num, 10));\n    }).replace(/&[a-zA-Z0-9#]+;/g, function (match) {\n        const text = {\n            '& eacute;': '',\n            '&quot;': '\"',\n            '&amp;': '&',\n            '&lt;': '<',\n            '&gt;': '>',\n            '&apos;': \"'\",\n            // Add more HTML entities here as needed\n        };\n        return text[match] || match;\n    });\n    return element;\n}\n\nif (apiResponse && apiResponse.results && apiResponse.results.length > 0) {\n    const triviaFacts = apiResponse.results.map(trivia => {\n        // Decode HTML entities in the question and answer fields\n        const decodedQuestion = decodeHTML(trivia.question);\n        const decodedAnswer = decodeHTML(trivia.correct_answer);\n\n        return `ðŸ“š ${trivia.category}: ${decodedQuestion}\\nâœ… Answer: ${decodedAnswer}`;\n    });\n\n    let messageContent = triviaFacts.join('');\n    const maxLength = 4000;\n\n    if (messageContent.length > maxLength) {\n        messageContent = messageContent.slice(0, maxLength) + '...';\n    }\n\n    msg.payload = {\n        channelId: msg.channelId || 'unknown_channel',\n        content: messageContent || '[No trivia content available]',\n    };\n} else {\n    msg.payload = {\n        channelId: msg.channelId || 'unknown_channel',\n        content: '[Unable to fetch trivia. Please try again later.]'\n    };\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1370,
        "y": 180,
        "wires": [
            [
                "149d0ecd396c236a"
            ]
        ]
    },
    {
        "id": "88745405d2b1f870",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Command Handler",
        "func": "let message = null;\nlet channelId = null;\n\n// Check different possible locations for message content\nif (msg.payload) {\n    message = msg.payload.content ||\n        msg.payload.text ||\n        msg.payload.message ||\n        (typeof msg.payload === 'string' ? msg.payload : null);\n}\n\n// Check different possible locations for channel ID\nif (msg.payload) {\n    channelId = msg.payload.channel?.id ||\n        msg.payload.channelId ||\n        msg.payload.channel_id;\n}\n\n// If still no message, try stringifying the entire payload\nif (!message) {\n    message = JSON.stringify(msg.payload);\n}\n\n// Fallback channelId if not found\nif (!channelId) {\n    channelId = 'unknown_channel';\n}\n\n// Minimal processing to ensure something happens\nif (message) {\n    // Basic command processing\n    const command = (typeof message === 'string' ? message : '').trim().toLowerCase();\n\n    if (command === '!help') {\n        msg.payload = {\n            channelId: channelId,\n            content: `Here are the commands you can use:\n!coin - Flip a coin and get Heads or Tails\n!dice [sides] - Roll a dice (default 6 sides)\n!trivia - Get trivia questions\n!daily - Get a daily fun fact\n!joke - get a random joke (warning this might contain every type of humor)\n!quote - get a random quote \n!aquote - get a ranom anime quote\n!game - Get a game recommendation \n!music - Discover a trending song \n!anime - Recommend a random anime\n!manga - Recommend a random manga\n!movie - Recommend a random movie \n!truth - Truth or Dare: Truth edition \n!dare - Truth or Dare: Dare edition\n!mini - Play one of many minigames  \n\nTry one of these commands!`};\n        return [msg];\n    }\n}\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 220,
        "wires": [
            [
                "149d0ecd396c236a"
            ]
        ]
    },
    {
        "id": "472446546a35cc39",
        "type": "http request",
        "z": "f6f2187d.f17ca8",
        "name": "Fetch Fun Fact",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://uselessfacts.jsph.pl/today.json?language=en",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 710,
        "y": 300,
        "wires": [
            [
                "cd48fafa74be05d0"
            ]
        ]
    },
    {
        "id": "cd48fafa74be05d0",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Process Fun Fact Response",
        "func": "const apiResponse = msg.payload;\n\n// Ensure we have a valid response\nif (apiResponse && apiResponse.text) {\n    msg.payload = {\n        channelId: msg.originalMessage?.channelId || 'unknown_channel',\n        content: `ðŸ¤” Fun Fact of the Day: ${apiResponse.text}\\n\\nSource: [Click here](${apiResponse.permalink || 'https://uselessfacts.jsph.pl'})`\n    };\n} else {\n    msg.payload = {\n        channelId: msg.originalMessage?.channelId || 'unknown_channel',\n        content: '[Unable to fetch the fun fact. Please try again later.]'\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 300,
        "wires": [
            [
                "149d0ecd396c236a"
            ]
        ]
    },
    {
        "id": "bf5da9aa1cd098aa",
        "type": "http request",
        "z": "f6f2187d.f17ca8",
        "name": "Fetch Joke",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://v2.jokeapi.dev/joke/Any?format=txt",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 700,
        "y": 340,
        "wires": [
            [
                "9b1ae8d80f61bca5"
            ]
        ]
    },
    {
        "id": "9b1ae8d80f61bca5",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Process Joke",
        "func": "msg.payload = {\n    content: `ðŸ˜‚ ${msg.payload}`\n};\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1390,
        "y": 340,
        "wires": [
            [
                "149d0ecd396c236a"
            ]
        ]
    },
    {
        "id": "cc197a5197dac1c0",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Process Anime Response",
        "func": "const anime = msg.payload.data;\nif (anime && anime.title && anime.url) {\n    msg.payload = {\n        content: `ðŸŽ¥ Here's an anime recommendation:\n        **${anime.title}**\n        [Watch Here](${anime.url})`\n            };\n        } else {\n            msg.payload = {\n                content: 'Could not fetch an anime recommendation. Try again later.'\n                };\n                }\n        return msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1360,
        "y": 380,
        "wires": [
            [
                "149d0ecd396c236a"
            ]
        ]
    },
    {
        "id": "596134bce5348145",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Dice Command Handler",
        "func": "let message = null; \nlet channelId = null; \nif (msg.payload) { \n    message = msg.payload.content || msg.payload.text || msg.payload.message || \n    (typeof msg.payload === 'string' ? msg.payload : null); \n    } \nif (msg.payload) { \n    channelId = msg.payload.channel?.id || msg.payload.channelId || msg.payload.channel_id; \n    } \nif (!message) { \n    message = JSON.stringify(msg.payload); \n    } \nif (!channelId) { \n    channelId = 'unknown_channel'; \n    } \nif (message) { \n    const command = (typeof message === 'string' ? message : '').trim().toLowerCase(); \n    const diceMatch = command.match(/^!dice\\s*(\\d+)?$/); \n    if (diceMatch) { let sides = diceMatch[1] ? parseInt(diceMatch[1], 10) : 6; \n    if (isNaN(sides) || sides < 3 || sides > 100) { \n        msg.payload = { channelId: channelId, content: \"âŒ Invalid dice! Please specify a number of sides between 3 and 100.\\n\\nExample usage:\\nâ€¢ !dice (6-sided die)\\nâ€¢ !dice 20 (20-sided die)\\nâ€¢ !dice 100 (100-sided die)\" }; \n        } \n        else { \n            const roll = Math.floor(Math.random() * sides) + 1; \n            msg.payload = { \n                channelId: channelId, content: \"ðŸŽ² You rolled a \" + sides + \"-sided die and got: \" + roll + \"!\" \n                }; \n                } \n                return [msg]; \n                } \n                } \n                return null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1040,
        "y": 100,
        "wires": [
            [
                "149d0ecd396c236a"
            ]
        ]
    },
    {
        "id": "96a7b8458dd6e819",
        "type": "http request",
        "z": "f6f2187d.f17ca8",
        "name": "Fetch Anime Recommendation",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://api.jikan.moe/v4/random/anime",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 760,
        "y": 380,
        "wires": [
            [
                "cc197a5197dac1c0"
            ]
        ]
    },
    {
        "id": "7dc0d7b7b48fe645",
        "type": "http request",
        "z": "f6f2187d.f17ca8",
        "name": "Fetch Truth",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://api.truthordarebot.xyz/v1/truth",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 700,
        "y": 660,
        "wires": [
            [
                "666075b79ab859a1"
            ]
        ]
    },
    {
        "id": "666075b79ab859a1",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Process Truth",
        "func": "if (msg.payload && msg.payload.question) {\n    msg.payload = { content: `ðŸ¤” Truth: ${msg.payload.question}` };\n} else {\n    msg.payload = { content: 'Could not fetch a truth. Try again later.' };\n}\nreturn msg;",
        "outputs": 1,
        "x": 1390,
        "y": 660,
        "wires": [
            [
                "149d0ecd396c236a"
            ]
        ]
    },
    {
        "id": "4dfc77995df55bd6",
        "type": "http request",
        "z": "f6f2187d.f17ca8",
        "name": "Fetch Dare",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://api.truthordarebot.xyz/v1/dare",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 700,
        "y": 700,
        "wires": [
            [
                "3cc9c3387965dfca"
            ]
        ]
    },
    {
        "id": "3cc9c3387965dfca",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Process Dare",
        "func": "if (msg.payload && msg.payload.question) {\n    msg.payload = { content: `ðŸ”¥ Dare: ${msg.payload.question}` };\n} else {\n    msg.payload = { content: 'Could not fetch a dare. Try again later.' };\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1390,
        "y": 700,
        "wires": [
            [
                "149d0ecd396c236a"
            ]
        ]
    },
    {
        "id": "fd30d90a3cd02d06",
        "type": "http request",
        "z": "f6f2187d.f17ca8",
        "name": "Fetch Game Suggestion",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://www.freetogame.com/api/games",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 740,
        "y": 580,
        "wires": [
            [
                "2724e1d3be3b5312"
            ]
        ]
    },
    {
        "id": "2724e1d3be3b5312",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Process Game Suggestion",
        "func": "if (msg.payload && Array.isArray(msg.payload) && msg.payload.length > 0) {const game = msg.payload[Math.floor(Math.random() * msg.payload.length)]; msg.payload = {content: `ðŸŽ® Game Recommendation: \n**${game.title}** \nGenre: ${game.genre || 'Unknown'} \nPlatform: ${game.platform || 'Unknown'} \nMore Details: ${game.freetogame_profile_url || 'N/A'}`};} else {msg.payload = {content: 'âŒ Could not fetch a game suggestion. Try again later.'};}return msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 580,
        "wires": [
            [
                "149d0ecd396c236a"
            ]
        ]
    },
    {
        "id": "dfe8f8dedae216eb",
        "type": "http request",
        "z": "f6f2187d.f17ca8",
        "name": "Fetch Music Recommendation",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://api.deezer.com/playlist/3155776842",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 760,
        "y": 620,
        "wires": [
            [
                "3ad7ae7542c8245d"
            ]
        ]
    },
    {
        "id": "3ad7ae7542c8245d",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Process Music Response",
        "func": "if (msg.payload && msg.payload.tracks && msg.payload.tracks.data) {\n    const tracks = msg.payload.tracks.data;\n    const randomTrack = tracks[Math.floor(Math.random() * tracks.length)];\n    const youtubeSearch = `https://www.youtube.com/results?search_query=${encodeURIComponent(randomTrack.artist.name + ' ' + randomTrack.title)}`;\n    msg.payload = {content: randomTrack ? `ðŸŽµ Song Recommendation: **${randomTrack.title}** by ${randomTrack.artist.name}\nðŸ“º Listen here: ${youtubeSearch}` : 'No tracks found.'};} \nelse {\n    msg.payload = { content: 'âŒ Could not fetch a music recommendation. Try again later.' };\n    }\n    return msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1360,
        "y": 620,
        "wires": [
            [
                "149d0ecd396c236a"
            ]
        ]
    },
    {
        "id": "86e101d5a252f9d3",
        "type": "switch",
        "z": "f6f2187d.f17ca8",
        "name": "!mini Commands",
        "property": "payload",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "!mini",
                "vt": "str"
            },
            {
                "t": "regex",
                "v": "!mini bj",
                "vt": "str",
                "case": true
            },
            {
                "t": "regex",
                "v": "!mini arch",
                "vt": "str",
                "case": true
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 700,
        "y": 780,
        "wires": [
            [
                "mini-games-handler"
            ],
            [
                "mini-games-handler"
            ],
            [
                "e986dc1ace054938"
            ]
        ]
    },
    {
        "id": "674563b76b6e91e3",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Process Manga Response",
        "func": "const manga = msg.payload.data;\nif (manga && manga.title && manga.url) {\n    msg.payload = {\n        content: `ðŸ“š Here's a manga recommendation:\n        **${manga.title}**\n        [Read Here](${manga.url})`\n    };\n} else {\n    msg.payload = {\n        content: 'Could not fetch a manga recommendation. Try again later.'\n    };\n}\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 420,
        "wires": [
            [
                "149d0ecd396c236a"
            ]
        ]
    },
    {
        "id": "cdd61a0d624b0e82",
        "type": "http request",
        "z": "f6f2187d.f17ca8",
        "name": "Fetch Manga Recommendation",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://api.jikan.moe/v4/random/manga",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 760,
        "y": 420,
        "wires": [
            [
                "674563b76b6e91e3"
            ]
        ]
    },
    {
        "id": "5a699ee4a565d261",
        "type": "http request",
        "z": "f6f2187d.f17ca8",
        "name": "Fetch Random Movie",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://api.themoviedb.org/3/movie/popular?api_key=cfb2e92eb071e974522cf6b9cdb8a3bd&language=en-US&page=1",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 730,
        "y": 460,
        "wires": [
            [
                "c65448f56e28c6c7"
            ]
        ]
    },
    {
        "id": "c65448f56e28c6c7",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Format Movie Details",
        "func": "const movies = msg.payload.results;\n\nif (movies && movies.length > 0) {\n    const randomMovie = movies[Math.floor(Math.random() * movies.length)];\n    msg.payload = {\n        content: `ðŸŽ¬ Movie Recommendation:\n**${randomMovie.title} (${randomMovie.release_date.split('-')[0]})**\n\n**Plot:** ${randomMovie.overview}\n\n**Actors:** Not available :popcorn:`\n    };\n} else {\n    msg.payload = {\n        content: 'Could not fetch a movie recommendation.'\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1370,
        "y": 460,
        "wires": [
            [
                "149d0ecd396c236a"
            ]
        ]
    },
    {
        "id": "e986dc1ace054938",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Check Command",
        "func": "let command = msg.payload ? msg.payload.toLowerCase() : '';\n\nif (command === '!mini arch') {\n    // Set up the URL for the API call\n    msg.url = 'https://db.ygoprodeck.com/api/v7/archetypes.php';\n    return msg;\n} else {\n    msg.payload = 'Invalid command. Please use `!mini arch` to get a random Yu-Gi-Oh! archetype.';\n    return msg;\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 820,
        "wires": [
            [
                "82a696bf26e6ce5f"
            ]
        ]
    },
    {
        "id": "82a696bf26e6ce5f",
        "type": "http request",
        "z": "f6f2187d.f17ca8",
        "name": "Get All Archetypes",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1120,
        "y": 820,
        "wires": [
            [
                "4e79f71058462811"
            ]
        ]
    },
    {
        "id": "4e79f71058462811",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Select Random Archetype",
        "func": "if (Array.isArray(msg.payload) && msg.payload.length > 0) {\n    // Pick a random archetype from the list\n    let randomIndex = Math.floor(Math.random() * msg.payload.length);\n    let randomArchetype = msg.payload[randomIndex].archetype_name;\n\n    // Send the response back to the user\n    msg.payload = `Your random Yu-Gi-Oh! archetype is: ${randomArchetype}`;\n    return msg;\n} else {\n    msg.payload = 'No archetypes found. Please try again later.';\n    return msg;\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1340,
        "y": 820,
        "wires": [
            [
                "149d0ecd396c236a"
            ]
        ]
    },
    {
        "id": "2b8eaaee04854c80",
        "type": "http request",
        "z": "f6f2187d.f17ca8",
        "name": "Fetch Random Quote",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "https://zenquotes.io/api/random",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 730,
        "y": 500,
        "wires": [
            [
                "7cf8c2027e3ff248"
            ]
        ]
    },
    {
        "id": "7cf8c2027e3ff248",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Process Quote Response",
        "func": "const apiResponse = msg.payload;\n\n// Ensure we have a valid response\nif (Array.isArray(apiResponse) && apiResponse.length > 0) {\n    const quote = apiResponse[0];\n    if (quote.q && quote.a) {\n        msg.payload = {\n            channelId: msg.originalMessage?.channelId || 'unknown_channel',\n            content: `ðŸ’¡ **Random Quote:**\\n\\\"${quote.q}\\\"\\n\\n- *${quote.a}*`\n        };\n    } else {\n        msg.payload = {\n            channelId: msg.originalMessage?.channelId || 'unknown_channel',\n            content: '[Unable to fetch a valid quote. Please try again later.]'\n        };\n    }\n} else {\n    msg.payload = {\n        channelId: msg.originalMessage?.channelId || 'unknown_channel',\n        content: '[Unable to fetch a random quote. Please try again later.]'\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1360,
        "y": 500,
        "wires": [
            [
                "149d0ecd396c236a"
            ]
        ]
    },
    {
        "id": "a759f82b5f7d4f6a",
        "type": "http request",
        "z": "f6f2187d.f17ca8",
        "name": "Fetch Random Anime Quote",
        "method": "GET",
        "ret": "obj",
        "url": "https://animechan.io/api/v1/quotes/random",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 750,
        "y": 540,
        "wires": [
            [
                "d14b7d35d2b2cd99"
            ]
        ]
    },
    {
        "id": "d14b7d35d2b2cd99",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Process Anime Quote Response",
        "func": "const apiResponse = msg.payload;\n\n// Check if the response contains the expected data\nif (apiResponse && apiResponse.data) {\n    const quote = apiResponse.data.content;\n    const anime = apiResponse.data.anime.name;\n    const character = apiResponse.data.character.name;\n\n    msg.payload = {\n        channelId: msg.originalMessage?.channelId || 'unknown_channel',\n        content: `ðŸ’¡ **Anime Quote:**\\n\\\"${quote}\\\"\\n\\n- *${character}* from *${anime}*`\n    };\n} else {\n    msg.payload = {\n        channelId: msg.originalMessage?.channelId || 'unknown_channel',\n        content: '[Unable to fetch a valid anime quote. Please try again later.]'\n    };\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1340,
        "y": 540,
        "wires": [
            [
                "149d0ecd396c236a"
            ]
        ]
    },
    {
        "id": "mini-games-handler",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Mini Games Handler",
        "func": "// Helper Functions\nfunction dealCard() {\n    return Math.floor(Math.random() * 10) + 1;\n}\n\nfunction calculateHandTotal(hand) {\n    return hand.reduce((total, card) => total + card, 0);\n}\n\n// Command Handling\nconst command = msg.payload.toLowerCase();\nconst args = msg.payload.split(' ').slice(1);\n\n// Game Variables\nlet playerHand = global.get('playerHand') || [];\nlet botHand = global.get('botHand') || [];\nlet gameState = global.get('gameState') || { blackjack: false };\n\n// Display Available Mini-Games\nif (command === \"!mini\") {\n    msg.payload = `**Available Mini-Games:**\\n1. Blackjack (!mini bj)(Play a game of Black jack)\\n2. Yugioh archetypes (!mini arch)(Get A random Yugioh Archetype)`;\n    return msg;\n}\n\n// Blackjack Game Logic\nif (command.startsWith(\"!mini bj\")) {\n    if (command === \"!mini bj start\") {\n        playerHand = [dealCard(), dealCard()];\n        botHand = [dealCard(), dealCard()];\n        global.set('playerHand', playerHand);\n        global.set('botHand', botHand);\n        global.set('gameState', { blackjack: true });\n\n        const playerTotal = calculateHandTotal(playerHand);\n\n        if (playerTotal === 21) {\n            const botTotal = calculateHandTotal(botHand);\n            global.set('gameState', { blackjack: false });\n            global.set('playerHand', []);\n            global.set('botHand', []);\n            msg.payload = `**Blackjack Started!**\\n\\nYour cards: ${playerHand.join(\", \")} (Total: ${playerTotal}).\\nBot's cards: ${botHand.join(\", \")} (Total: ${botTotal}).\\n\\n**You got 21! You win!**`;\n            return msg;\n        }\n\n        msg.payload = `**Blackjack Started!**\\n\\nYour cards: ${playerHand.join(\", \")} (Total: ${playerTotal}).\\nBot's visible card: ${botHand[0]}, ?\\n\\nUse \\`!mini bj hit\\` or \\`!mini bj stand\\`.`;\n        return msg;\n    }\n\n    if (command === \"!mini bj hit\") {\n        if (!gameState.blackjack) {\n            msg.payload = \"Start a game first with `!mini bj start`.\";\n            return msg;\n        }\n\n        playerHand.push(dealCard());\n        const playerTotal = calculateHandTotal(playerHand);\n\n        if (playerTotal > 21) {\n            const botTotal = calculateHandTotal(botHand);\n            global.set('gameState', { blackjack: false });\n            global.set('playerHand', []);\n            global.set('botHand', []);\n            msg.payload = `Oh no, you have achieved a bust! Your cards: ${playerHand.join(\", \")} (Total: ${playerTotal}).\\nBot's cards: ${botHand.join(\", \")} (Total: ${botTotal}).\\n\\n**Bot wins!**`;\n            return msg;\n        }\n\n        if (playerTotal === 21) {\n            const botTotal = calculateHandTotal(botHand);\n            global.set('gameState', { blackjack: false });\n            global.set('playerHand', []);\n            global.set('botHand', []);\n            msg.payload = `**You got 21!** Your cards: ${playerHand.join(\", \")} (Total: ${playerTotal}).\\nBot's cards: ${botHand.join(\", \")} (Total: ${botTotal}).\\n\\n**You win!**`;\n            return msg;\n        }\n\n        global.set('playerHand', playerHand);\n        msg.payload = `Your cards: ${playerHand.join(\", \")} (Total: ${playerTotal}).\\nBot's visible card: ${botHand[0]}, ?\\n\\nUse \\`!mini bj hit\\` or \\`!mini bj stand\\`.`;\n        return msg;\n    }\n\n    if (command === \"!mini bj stand\") {\n        if (!gameState.blackjack) {\n            msg.payload = \"Start a game first with `!mini bj start`.\";\n            return msg;\n        }\n\n        const playerTotal = calculateHandTotal(playerHand);\n        let botTotal = calculateHandTotal(botHand);\n\n        while (botTotal < 17 || (botTotal < playerTotal && botTotal <= 21)) {\n            botHand.push(dealCard());\n            botTotal = calculateHandTotal(botHand);\n        }\n\n        global.set('gameState', { blackjack: false });\n        global.set('playerHand', []);\n        global.set('botHand', []);\n\n        const baseMessage = `Your cards: ${playerHand.join(\", \")} (Total: ${playerTotal}).\\nBot's cards: ${botHand.join(\", \")} (Total: ${botTotal}).\\n\\n`;\n\n        if (botTotal > 21) {\n            msg.payload = baseMessage + `**The bot busts! You win!**`;\n        } else if (playerTotal > botTotal) {\n            msg.payload = baseMessage + \"**You win!**\";\n        } else if (playerTotal === botTotal) {\n            msg.payload = baseMessage + \"**It's a draw!**\";\n        } else {\n            msg.payload = baseMessage + \"**Bot wins!**\";\n        }\n        return msg;\n    }\n\n    msg.payload = \"Invalid Blackjack command. Use `!mini bj start`, `!mini bj hit`, or `!mini bj stand`.\";\n    return msg;\n}\n\n// Default Response\nmsg.payload = \"Invalid command. Use `!mini bj` (Blackjack), `!mini arch` (Yugioh archetypes), or `!mini` to view games.\";\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1350,
        "y": 760,
        "wires": [
            [
                "149d0ecd396c236a"
            ]
        ]
    },
    {
        "id": "b84a5dc887db4132",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Parse Input Command",
        "func": "const input = msg.payload.trim();\n\nif (!input.startsWith('!mtrivia')) {\n    return null; // Ignore non-target commands\n}\n\nconst parts = input.split(' ');\nmsg.payload = {\n    command: parts[0],\n    count: parts[1] ? parseInt(parts[1], 10) : 1\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 670,
        "y": 220,
        "wires": [
            [
                "a2514a17de77ab20"
            ]
        ]
    },
    {
        "id": "a2514a17de77ab20",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Check Command and Prepare Request",
        "func": "if (msg.payload.command !== '!mtrivia') {\n    return null; // Ignore if the command is not '!mtrivia'\n}\n\nconst count = parseInt(msg.payload.count, 10) || 1; // Default to 1 trivia fact if not provided\nmsg.url = `https://opentdb.com/api.php?amount=${count}&category=20`; // Mythology\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 930,
        "y": 260,
        "wires": [
            [
                "a5be2d6552a4b276"
            ]
        ]
    },
    {
        "id": "a5be2d6552a4b276",
        "type": "http request",
        "z": "f6f2187d.f17ca8",
        "name": "Fetch Mythology Trivia from API",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "{{{url}}}",
        "x": 1240,
        "y": 260,
        "wires": [
            [
                "02e831515137dbbc"
            ]
        ]
    },
    {
        "id": "02e831515137dbbc",
        "type": "function",
        "z": "f6f2187d.f17ca8",
        "name": "Process API Response",
        "func": "// Processing logic here\nreturn msg;",
        "outputs": 1,
        "x": 1470,
        "y": 220,
        "wires": [
            [
                "149d0ecd396c236a"
            ]
        ]
    }
]